# -*- coding: utf-8 -*-
"""
Finds gaps in geographic point data.

Intended for buildings footprints (really centroids) by dividing the space into
vertical and horizontal strips. Large gaps of points in these strips along 
their long axis are used to map out areas without any buildings present.

Intended for use with MS buildings, where missing image tiles result in data  
gaps with a square shaped pattern, so this script tries to filter out
irregularly shaped gaps with jagged edges, but can be tuned to be more or less
sensitive to irregular shapes.

Returns a GeoDataFrame of either points of where horizontal and vertical gaps
intersect, or polygons generated by alpha shapes from these points.
"""

__author__ = "Jack Gonzales"

import os
import sys
from operator import itemgetter

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.collections as mc
import pylab as pl
import geopandas as gpd
import shapely
from libpysal.cg import alpha_shape
from shapely.geometry import LineString
from shapely.geometry import Point
from shapely.geometry import MultiPoint
from shapely.geometry import MultiPolygon

# ------------------Load points from geojson------------------
def loadPoints(filePath):
    """Load in points from geojson and return as GeoDataframe"""
    gdf = gpd.read_file(filePath)
    
    return gdf

# -----------------Put coordinates in np array----------------
def getCoordinates(points):
    """Get point coordinates in numpy array out of geodataframe.
    
    Parameters
    ----------
    points : GeoDataFrame
             Set of building centroids, as loaded in by loadPoints

    Returns
    -------
    ndarray
        Array of point coordinates (x,y)
    """
    pointGeom = points['geometry']
    
    pointsCoords = np.zeros([np.size(pointGeom),2])

    i = 0
    for point in pointGeom:
        if type(point) == MultiPoint:
            for p in point.geoms:
                pointsCoords[i,0] = p.x
                pointsCoords[i,1] = p.y
        elif type(point) == Point:
            pointsCoords[i,0] = point.x
            pointsCoords[i,1] = point.y
        i += 1
    
    return pointsCoords

# ----------Put points into bins based on lat and lon---------
def intoTheBins(points, xBinSize=0.005, yBinSize=0.005):
    """Sorts points into latidude and longitude bins.
    
    Points go into two sets of bins based on their latitude (y) and
    longitude (x). Calls intoTheXBins and intoTheYBins to handle the x and y 
    bins respectively.
    
    Parameters
    ----------
    points : ndarray
             Array of n number of point coordinates (x,y) of shape (n,2)
    xBinSize : float, optional
               Size of x bins, i.e. strip width, in the same units as the
               projection used for buildings centroids
    yBinSize : float, optional
               Size of y bins, i.e. strip width, in the same units as the
               projection used for building centroids 
    
    Returns
    -------
    pointsInBins : ndarray
                   Array of shape (n, 4)  containing all the coordinates of n
                   points with indices of the bins each point falls in in 
                   `xBins` and `yBins`. Format:
                   [latitude(y), longitude(x), `yBin` index, `xBin` index
                        ...          ...            ...           ...    ]
    yBins : ndarray
            Array of shape (n, 1) containing latitude values for each bin
    xBins : ndarray
            Array of shape (n, 1) containing longitude values for each bin
    """

    # -------------------Sort points into X bins------------------
    def intoTheXBins(points, binSize=0.005):
        """Sorts points into bins based on their longitude (x) value. 

        Bins are evenly spaced on intervals defined by `binSize.

        Parameters
        ----------
        points : ndarray
                 Array of n number of point coordinates (x,y) of shape (n,2)
        binSize : float, optional
                  Width of each bin, aka strip

        Returns
        -------
        binAssignment : ndarray
                        Bin index for each point
        bins : ndarray
               Coordinates of the center of each bin
         """

        xMax = max(points[:,0])
        xMin = min(points[:,0])
        bins = np.arange(xMin, (xMax + binSize), step=binSize)

        # build extra column of which bin index each point goes in
        binAssignment = np.zeros(np.shape(points[:,0]))

        # put points into whichever bin they are closest to
        i = 0
        for aBin in binAssignment:
            diffs = np.abs(points[i,0] - bins[:])
            binIndex = np.where(min(diffs) == np.abs(points[i,0] - bins[:]))[0]

            binAssignment[i] = binIndex

            i+=1

        return binAssignment, bins

    # -------------------Sort points into y bins------------------
    def intoTheYBins(points, binSize=0.005):
        """Sorts points into bins based on their latitude (y) value. 

        Bins are evenly spaced on intervals defined by `binSize.`

        Parameters
        ----------
        points : ndarray
                 Array of n number of point coordinates (x,y) of shape (n,2)
        binSize : float, optional
                  Width of each bin aka strip

        Returns
        -------
        binAssignment : ndarray
                        Bin index for each point
        bins : ndarray
               Coordinates of the center of each bin
         """

        yMax = max(points[:,1])
        yMin = min(points[:,1])
        bins = np.arange(yMin, (yMax + binSize), step=binSize)


        # build extra column of which bin index each point goes in
        binAssignment = np.zeros(np.shape(points[:,1]))

        # put points into whichever bin they are closest to
        i = 0
        for aBin in binAssignment:
            diffs = np.abs(points[i,1] - bins[:])
            binIndex = np.where(min(diffs) == np.abs(points[i,1] - bins[:]))[0]

            binAssignment[i] = binIndex

            i+=1

        return binAssignment, bins
    
    binXIndices, xBins = intoTheXBins(points, xBinSize)
    binYIndices, yBins = intoTheYBins(points, yBinSize)

    pointsInBins = np.vstack((points[:,0],
                              points[:,1],
                              binYIndices,
                              binXIndices)).T

    return pointsInBins, xBins, yBins

# ----------------Go through xBins to find gaps---------------
def findLatGaps(points, bins, gapLengthThreshold=0.05):
    """Finds gaps in longitude bins.
    
    For each longitude bin, this function takes all points that fall within 
    that bin, and compresses them to one dimension by only considering their
    latitude coordinate, so that the fall on a number line along the bin's
    long axis. Gaps are found by finding the distance between each
    successive point, and filtering out all gaps that do not meet a minimum
    length threshold.
       
    Parameters
    ----------
    points :  array_like
              Array of points including coordinates, y Bin indices, and x bin 
              indices
    bins : array_like
           Array of bin longitude (x) coordinates.
    gapLengthThreshold : float, optional
                         Minimum length gaps must meet to be returned

    Returns
    -------
    gaps : list
           List of gaps, where each individual gap is a list containing the bin
           index, bin longitude coordinate, endpoint 1 index, endpoint 1 
           latiude coordinate, endpoint 2 index, endpoint 2 latitude 
           coordinate, and length.
    """

    gaps = []

    i = 0
    for binn in bins:
        # Find indices of points in that bin
        indicesInBin = np.where(points[:,3] == i)[0]
        
        # If there aren't any gaps in this bin, skip to the next one
        if np.shape(indicesInBin)[0] == 0:
            i += 1
            continue        
        
        # Sort latitudes into numerical order
        latsInBin = points[indicesInBin,1]
        latsSorted = latsInBin[np.argsort(latsInBin)]
        
        # Calcuate distances between each successive point
        successiveDists = np.zeros((np.shape(latsSorted)[0]-1,1))
        for j in range(np.shape(successiveDists)[0]):
            successiveDists[j] = np.abs(latsSorted[j + 1] - latsSorted[j])
        
        # Do some basic stats
        try:    
            distStd = np.std(successiveDists)
            distMax = max(successiveDists)
        
            # If large gaps are present, where are they?
            if distMax >= (gapLengthThreshold):
                bigDistInds = np.where(successiveDists >= 
                                       (gapLengthThreshold))[0]
            
                # Append each gap's info to list of all gaps
                for gapInd in bigDistInds:
                    thisGap = [i,
                               binn,
                               gapInd,
                               latsSorted[gapInd],
                               gapInd + 1,
                               latsSorted[gapInd + 1],
                               successiveDists[gapInd][0]]
                    gaps.append(thisGap)
        except Exception:
            pass
        finally:
            i += 1
            
    return gaps

# ----------------Go through yBins to find gaps---------------
def findLonGaps(points, bins, gapLengthThreshold=0.05):
    """Finds data gaps in latitude bins.
    
    For each latitude bin, this function takes all points that fall within 
    that bin, and compresses them to one dimension by only considering their
    longitude coordinate, so that the fall on a number line along the bin's
    long axis. Gaps are found by finding the distance between each
    successive point, and filtering out all gaps that do not meet a minimum
    length threshold.
       
    Parameters
    ----------
    points :  array_like
              Array of points including coordinates, y Bin indices, and x bin 
              indices
    bins : array_like
           Array of bin latitude (y) coordinates.
    gapLengthThreshold : float, optional
                         Minimum length gaps must meet to be returned

    Returns
    -------
    gaps : list
           List of gaps, where each individual gap is a list containing the bin
           index, bin latitude coordinate, endpoint 1 index, endpoint 1 
           longitude coordinate, endpoint 2 index, endpoint 2 longitude 
           coordinate, and length.
    """

    gaps = []
    
    i = 0
    for binn in bins:
        # Find indices of points in that bin
        indicesInBin = np.where(points[:,2] == i)[0]
        
        # If there aren't any gaps in this bin, skip to the next one
        if np.shape(indicesInBin)[0] == 0:
            i += 1
            continue
        
        # Sort latitudes into numerical order
        lonsInBin = points[indicesInBin,0]
        lonsSorted = lonsInBin[np.argsort(lonsInBin)]
        
        # Calcuate distances between each successive point
        successiveDists = np.zeros((np.shape(lonsSorted)[0]-1,1))
        for j in range(np.shape(successiveDists)[0]):
            successiveDists[j] = np.abs(lonsSorted[j + 1] - lonsSorted[j])
        
        # Do some basic stats
        try:    
            distStd = np.std(successiveDists)
            distMax = max(successiveDists)
        
            # If large gaps are present, where are they?
            if distMax >= (gapLengthThreshold):
                bigDistInds = np.where(successiveDists >= 
                                       (gapLengthThreshold))[0]
            
                # Append each gap's info to list of all gaps
                for gapInd in bigDistInds:
                    thisGap = [i,
                               binn,
                               gapInd,
                               lonsSorted[gapInd],
                               gapInd + 1,
                               lonsSorted[gapInd + 1],
                               successiveDists[gapInd][0]]
                    gaps.append(thisGap)
        except Exception:
            pass
        finally:
            i += 1
            
    return gaps

# ---------------------Find Adjacent gaps---------------------
def isAdjacent(gap1, gap2, gapSize):
    """Tests to see if two gaps are adjacent. 
    
    Parameters
    ----------
    gap1 : array_like
           The first gap to test, containing the bin index, bin lat or lon 
           coordinate, endpoint 1 index, endpoint 1 lat or lon coordinate, 
           endpoint 2 index, endpoint 2 lat or lon coordinate, and length.
    gap2 : array_like
           The first gap to test, containing the bin index, bin lat or lon
           cooridinate, endpoint 1 index, endpoint 1 lat or lon coordinate,
           endpoint 2 index, endpoint 2 lat or lon coordinate, and length.
    gapSize : float
              The width of each gap or bin

    Returns
    -------
    int
        0 if not adjacent, 1 if partially adjacent (one pair of endpoints 
        match), and 2 if fully adjacent (both pairs of endpoints match)

    Notes
    -----
    Both gaps must have the same orientation.
    This function is not used and I'm not 100% sure it works properly.
    """
    
    gap1Bin = gap1[1]
    gap2Bin = gap2[1]
    if (np.abs(gap1Bin - gap2Bin) > gapSize):
        return 0
    
    else:
        # Find if only one or two endpoints are close (within some threshold)
        gap1End1 = np.asarray([gap1[1], gap1[3]])
        gap1End2 = np.asarray([gap1[1], gap1[5]])
        gap2End1 = np.asarray([gap2[1], gap2[3]])
        gap2End2 = np.asarray([gap2[1], gap2[5]])
        
        gapEndDists = [np.linalg.norm(gap1End1-gap2End1),
                       np.linalg.norm(gap1End1-gap2End2),
                       np.linalg.norm(gap1End2-gap2End1),
                       np.linalg.norm(gap1End2-gap2End2)]
        
        numCloseEnds = 0
        for dist in gapEndDists:
            if dist < .05: # If distance is within some threshold distance
                numCloseEnds += 1
                
                if numCloseEnds == 2:
                    return numCloseEnds
                    break
                
            return numCloseEnds

# --------------Find if a pair of segments cross--------------
def doesCross(xGap, yGap):
    """Finds if a y gap and x gap cross.
    
    Paramters
    ---------
    xGap : array_like
           a single `xGap`, containing the bin index, bin lon coordinate,
           endpoint 1 index, endpoint 1 lat coordinate, endpoint 2 index,
           endpoint 2 coordinate, and length
    yGap : array_like
           a single `yGap`, containing the bin index, bin lat coordinate,
           endpoint 1 index, endpoint 1 lon coordinate, endpoint 2 index,
           endpoint 2 coordinate, and length
           
    Returns
    -------
    boolean
        True if `xGap` and `yGap` do cross, False if they don't
        
    Notes
    -----
    xGap and yGap can actually be interchanged. Can also correctly handle
    parallel gaps/line segments, returning False
    """
    
    # Put all coordinates into easier to deal with variables
    xGx = xGap[1]
    xGy1 = xGap[3]
    xGy2 = xGap[5]
    yGy = yGap[1]
    yGx1 = yGap[3]
    yGx2 = yGap[5]
    
    if((yGx1<=xGx<=yGx2) and (xGy1<=yGy<=xGy2)):
        return True
    else:
        return False
    
# ---------------------Find intersections---------------------
def findIntersections(gapLineStrings):
    """Finds intersections amongst a set of LineStrings.
    
    Finds intersections between LineStrings using the 
    shapely.LineString.intersection method.
       
    Parameters
    ----------
    gapLineStrings : list
                     List containing LineString objects
    
    Returns
    -------
    intersections : list
                    List containing shapely points of each intersection between
                    lines in `gapLineStrings`

    Notes
    -----
    `gapLineStrings` should be a list of Linestrings defining line segments, 
    not multilines, so the maximum number of intersections between a pair of
    items in `gapLineStrings` should be 1, and `intersections` should only
    contain points, not multipoints.
    """
    intersections = []
    for y in range(len(gapLineStrings)):
        ln1 = gapLineStrings[y]
        for h in range(len(gapLineStrings)):
            ln2 = gapLineStrings[h]
            cross = ln1.intersection(ln2)
            if cross.is_empty or y == h or type(cross) == LineString:
                continue
            else:
                intersections.append(cross)

    return intersections

# -----------Filter out gaps with few intersections-----------    
def intersectionFilter(_xGaps,_yGaps,xMinIntersections=3,yMinIntersections=3):
    """Removes lines that don't meet a minimum number of intersections.
    
    Filters out gaps that don't intersect with a minimum number of other
    gaps, until no more  gaps can be filtered out.
       
    Parameters
    ----------
    _xGaps : array_like
             Array of gaps on the x bins containing containing the bin indices, 
             bin lon coordinates, endpoint 1 indices, endpoint 1 lat 
             coordinates, endpoint 2 indices, endpoint 2 coordinates, and 
             length
    _yGaps : array_like
             Array of gaps on the y bins containing containing the bin indices,
             bin lat coordinates, endpoint 1 indices, endpoint 1 lon 
             coordinates, endpoint 2 indices, endpoint 2 coordinates, and 
             length
    xMinIntersections : int, optional
                        Minumum number of intersections a gap in `_xGaps` must 
                        have with other gaps in order to be retained.
    yMinIntersections : int, optional
                        Minumum number of intersections a gap in `_yGaps` must 
                        have with other gaps in order to be retained.

    Returns
    -------
    _xGaps : array_like
             Array of _xGaps that have at least the minimum number of 
             intersections with other gaps
    _yGaps : array_like
             Array of _yGaps that have at least the minimum number of
             intersections with other gaps
    """
    
    # Convert gaps to np arrys
    _xGaps = np.asarray(_xGaps)
    _yGaps = np.asarray(_yGaps)
    
    # Filter repeatedly until things stop changing
    prevXGapsNum = 0
    prevYGapsNum = 0
    iterations = 0

    while True:
        xGapDoesCross = np.zeros(np.shape(_xGaps[:,1])[0])
        yGapDoesCross = np.zeros(np.shape(_yGaps[:,1])[0])

        for i in range(np.shape(_xGaps[:,1])[0]):
            thisXGap = _xGaps[i,:]
            for o in range(np.shape(_yGaps[:,1])[0]):
                thisYGap = _yGaps[o,:]
                
                if doesCross(thisXGap, thisYGap):
                    yGapDoesCross[o] += 1
                    xGapDoesCross[i] += 1

        # Remove gaps that don't have any connections
        connectingXGaps = np.where(xGapDoesCross >= xMinIntersections)[0] 
        _xGaps = _xGaps[connectingXGaps]
        connectingYGaps = np.where(yGapDoesCross >= yMinIntersections)[0]         
        _yGaps = _yGaps[connectingYGaps]
        
        # Compare number of gaps to previous iteration
        xGapsNumDiff = np.shape(_xGaps[:,1])[0] - prevXGapsNum
        yGapsNumDiff = np.shape(_yGaps[:,1])[0] - prevYGapsNum
        
        if (xGapsNumDiff == 0) and (yGapsNumDiff == 0):
            break
        
        # Save number of gaps for this iteration
        prevXGapsNum = np.shape(_xGaps[:,1])[0]
        prevYGapsNum = np.shape(_yGaps[:,1])[0]
        
        iterations += 1
    
    # print("Filter iterations: " + str(iterations))
    
    return _xGaps, _yGaps

# -------------Find clusters of connecting lines--------------         
def findClusters(_xGaps, _yGaps):
    """Finds discrete clusters of interconnecting lines.
    
    Gaps are often isolated from one another, resulting in discrete newtorks
    or clusters of intersecting lines. This function gathers all lines in
    each cluster and returns all lines sorted into separate lists for each
    cluster.
       
    Parameters
    ----------
    _xGaps : array_like
             Array of gaps on the x bins containing containing the bin indices, 
             bin lon coordinates, endpoint 1 indices, endpoint 1 lat 
             coordinates, endpoint 2 indices, endpoint 2 coordinates, and 
             length
    _yGaps : array_like
             Array of gaps on the y bins containing containing the bin indices,
             bin lat coordinates, endpoint 1 indices, endpoint 1 lon 
             coordinates, endpoint 2 indices, endpoint 2 coordinates, and 
             length

    Returns
    -------
    allGaps : ndarray
              Array of all all x and y gaps stacked together
    gapClusterIDs : ndarray
                    Array of unique ID numbers for each cluster, indexing from
                    one.
    clusters : list
               List containing a list of indices refering to `allGaps` for
               each cluster
    splitIndex : int
                 Index of where `allGaps` shifts from being _xGaps to _yGaps
    """
    
    def takeAWalk(gaps,startInd,doneInds=[],crossInds=[]):
        """Finds all lines in a network of interconnecting lines.

        Starting from one gap/line segment, this function gets all other
        line segments that intersect with the start line segment, and adds 
        the indices of those intersecting lines in `gaps` to a list. Then,
        for each intersecting line segment not already in the list of
        intersecting indices, the function recursively calls itself to find 
        all line segments that intersect with each of those line segments, 
        and then calls itself again, etc. This finally ends when all line
        segments of a cluster are added to `crossInds` and no more recursive
        calls are made.
           
        Parameters
        ----------
        gaps : array_like
              `allGaps` from the parent function
        startInd : int
                   Index in `gaps` of the first gap to test
        doneInds : array_like, optional
                   Indices of gaps that have already been tested
        crossInds : array_like, optional
                    Indices of line segments that cross at least one other line
                    segment in the cluster

        Returns
        -------
        crossInds : array_like
                    Indices in `gaps` (`allGaps` in parent function) of line
                    segments that are in the cluster
        """
        
        # Make sure we haven't already ran this index
        if startInd in doneInds:
            return 
        else:
            doneInds.append(startInd)
        
        # Define test gap
        testGap = gaps[startInd,:]
        
        # Find which other gaps intersect with our test gap
        for i in range(np.shape(gaps[:,1])[0]):
            # If the gap crosses our test gap and isn't already in crossInds,
            # then we append it. We also make recursive call of takeAWalk
            if doesCross(testGap,gaps[i,:]) and (not(i in crossInds)):
                crossInds.append(i)
                crossInds.append(takeAWalk(gaps,
                                           i,
                                           doneInds,
                                           crossInds=crossInds))
        
        return crossInds
    
    # Stack all gaps into one big array
    allGaps = np.vstack([_xGaps,_yGaps])
    # Get the index that splits xGaps and yGaps
    splitIndex = np.shape(_xGaps[:,1])[0]
    # Create array of cluster IDs
    gapClusterIDs = np.zeros(np.shape(allGaps[:,1])[0])
    
    # Make lists of clusters and all indices in clusters
    clusters = []
    inClusters = []

    # Make list of all gap indices
    allGapInds = list(range(0,len(allGaps[:,0])))

    # start cluster ID
    clusterID = 0 
    
    # Sort into clusters
    while inClusters.sort() != allGapInds:
        # Find the gap we want to walk from: the first gap that hasn't yet been
        # assigned to a cluster. If an IndexError is thrown, then all gaps have
        # been sorted into clusters and we break out of the loop
        try:
            walkInd = np.where(gapClusterIDs == 0)[0][0]
        except IndexError:
            break
        
        # global inCluster
        inCluster = takeAWalk(allGaps, walkInd, doneInds=[], crossInds=[])
        
        # takeAWalk returns a very messy list, including other lists.
        # We only want the integers from it.
        inCluster = list([elm for elm in inCluster if isinstance(elm, int)])
        # append all gaps in a cluster into list of lists of cluster indices
        clusters.append(inCluster)
        # Add gaps to list of all clustered indices
        inClusters += inCluster
        # Assign all gaps in that cluster with their cluster ID
        gapClusterIDs[inCluster] = clusterID
        # Move to next cluster ID
        clusterID += 1
                
    return allGaps, gapClusterIDs, clusters, splitIndex#Return gaps with cluster ID

# ---------------------Find corner points---------------------         
def findCorners(points):
    """Finds the corners in a set of perimeter points.

    Parameters
    ----------
    points : array_like
             All the points that make up the shape outline. List of 2-element
             np arrays
    
    Returns
    -------
    trueCorners : array_like
                  All corner points. List of 2-element np arrays
    """
    
    def isCorner(points, index):
        """Determines whether or not a point is a corner or on an edge. 
        
        It does this by taking a set of perimeter points, with the index of a 
        point of interest. The point of interest and its two adjacent neighbors
        are then projected into a 3D space, with all having a z value of zero. 
        Then the cross product of vectors connecting the point of interest to 
        the neighbors is taken. A cross product of zero indicates the points 
        are aligned, and that the point of interest is on an edge. A nonzero 
        cross product indicates that the point is a corner.

        Parameters
        ----------
        points : array_like
                 List of all outer points in clockwise order
        index : int
                Index of the point of interest in `points`

        Returns
        -------
        boolean
            True if the point of interest is a corner, False if not

        Notes
        -----
        Considering point p, with neighbors p and q, the following will be true
        for a point lying on an edge:
        
        .. math::  overrightarrow{pq}  times overrightarrow{pr}  =  0

        Any other result indicates a corner.
        """

        # def isConcaveCorner(pointOfInterest):
        #     # tests to see if a corner is concave or not
        #     # pointOfInterest: The corner point in question
        #     # Define points
        #     pointOfInterest = np.asarray([pointOfInterest])
            
        #     # Define vectors
        #     v1 = pointOfInterest - neighbor1
        #     v2 = pointOfInterest - neighbor2
            
        #     # Calculate cross product
        #     crossProduct = np.cross(v1,v2)
            
        #     if crossProduct == np.asarray([0,0,0]):
        #         return False
        #     else:
        #         return True
            
        # Compute cross product to test if point is on an edge or corner
        p = np.hstack([points[i], 0])
        q = np.hstack([points[(i - 1) % len(points)], 0])
        r = np.hstack([points[(i + 1) % len(points)], 0])
        pq = p - q
        pr = p - r
        
        if np.linalg.norm(np.cross(pq,pr)) != 0:
            return True
        else:
            return False

    def isTrueCorner(points, corner):
        """Determines if a corner point is a true 90 degree corner.
           
        Parameters
        ----------
        points : array_like
                 List of clockwise ordered points
        corner : array_like
                 The corner point we are testing, plus its index in `points`

        Returns
        --------
        boolean
            True if it is a true 90 degree corner, False if not

        Notes
        -----
        To determine the angle of a corner, find the angle theta between 
        vectors connecting point p to neighbors q and r:

         .. mat:: \theta = arccos\big(\frac{\overrightarrow{pq}\bullet
         \overrightarrow{pr}}{\|\overrightarrow{pq}\|\|\overrightarrow{pr}\|}
         \big)
        """

        # Get neighbor points
        index = int(corner[2])
        neighbor1 = points[(index - 1) % len(points)]
        neighbor2 = points[(index + 1) % len(points)]
        
        # define vectors
        v1 = corner[0:2] - neighbor1
        v1Mag = np.linalg.norm(v1)
        v2 = corner[0:2] - neighbor2
        v2Mag = np.linalg.norm(v2)
        
        # get angle betwixt vectors
        theta = np.arccos(np.dot(v1,v2) / (v1Mag * v2Mag))
        if (theta % (np.pi / 2)) == 0:
            return True
        else:
            return False
        
    def findTrueCorner(points, falseCorner):
        """This function returns the true concave corner from a false corner.
        
        Paramters
        ---------
        points : array_like
                 Clockwise ordered list of points
        falseCorner : array_like
                      The corner point we are testing, plus its index in 
                      `points`
        
        Returns
        -------
        trueCorner : array_like
                     Three element ndarray, [x coord, y coord, 0]
        """

        # Get neighbor points
        index = int(corner[2])
        neighbor1 = points[(index - 1) % len(points)]
        neighbor2 = points[(index + 1) % len(points)]
        
        # find matching coordinate in neighbors
        if falseCorner[0] == neighbor1[0]:
            trueX = falseCorner[0]
            o = 1
            oldNeighbor = neighbor2
            
            while True:
                newNeighbor = points[(index + 1 + o) % len(points)]
                if newNeighbor[1] == oldNeighbor[1]:
                    trueY = newNeighbor[1]
                    break
                o += 1
                
        elif falseCorner[1] == neighbor1[1]:
            trueY = falseCorner[1]
            o = 1
            oldNeighbor = neighbor2
            
            while True:
                newNeighbor = points[(index + 1 + o) % len(points)]
                if newNeighbor[0] == oldNeighbor[0]:
                    trueX = newNeighbor[0]
                    break
                o += 1
        
        elif falseCorner[0] == neighbor2[0]:
            trueX = falseCorner[0]
            o = 1
            oldNeighbor = neighbor1
            
            while True:
                newNeighbor = points[(index + 1 + o) % len(points)]
                if newNeighbor[1] == oldNeighbor[1]:
                    trueY = newNeighbor[1]
                    break
                o += 1
        
        elif falseCorner[1] == neighbor2[1]:
            trueY = falseCorner[1]
            o = 1
            oldNeighbor = neighbor1
            
            while True:
                newNeighbor = points[(index + 1 + o) % len(points)]
                if newNeighbor[0] == oldNeighbor[0]:
                    trueX = newNeighbor[0]
                    break
                o += 1
        else:
            return
            
        trueCorner = np.asarray([trueX, trueY, 0])
        
        return trueCorner
        
    # Define corners list
    corners = []
    
    for i in range(len(points)):
        if isCorner(points, i):
            corners.append(np.hstack([points[i], i]))

    trueCorners = []
            
    # ---------------Tease out true concave corners---------------
    for corner in corners:
        if isTrueCorner(outerPoints, corner):
            trueCorners.append(corner)
        else:
            tCorner = findTrueCorner(outerPoints, corner)
            trueCorners.append(tCorner)
            
        
        
    # for point in points:
    #     # global p
    #     # global q
    #     # global r
    #     p = np.hstack([point,0])
    #     # find neighboring points
    #     dists = (np.linalg.norm(point - points[:],axis=-1))
    #     distsSorted = np.sort(dists)
    #     neighborDists = [distsSorted[1], distsSorted[2]]
    #     neighbor1Ind = np.where(neighborDists[0] == dists)[0]
    #     neighbor1 = points[neighbor1Ind[0]]
    #     q = np.hstack([neighbor1,0])
    #     neighbor2Ind = np.where(neighborDists[1] == dists)[0]
    #     neighbor2 = points[neighbor2Ind[0]]
    #     r = np.hstack([neighbor2,0])
    #     # print(p)
    #     # print(q)
    #     # print(r)
    #     pq = p - q
    #     pr = p - r
    #     pqXpr = (np.cross(pq,pr))
    #     if np.linalg.norm(pqXpr) != 0:
    #         corners.append(point)
    #     # print(pqXpr)
    #     # plt.scatter(point[0],point[1],c='#ff7f0e')
    #     neighbors = np.vstack([neighbor1,neighbor2])
    #     # plt.scatter(neighbors[:,0],neighbors[:,1],c='#bcbd22')
    #     # break

        
    
    return trueCorners
            
# ---------------Find outer intersection points---------------
def getOuterPoints(xInds, yInds, gaps):
    """Gets points on the perimeter of the data gap in clockwise order.
    
    Parameters
    ----------
    xInds : array_like
            Indices of all the xGaps in `gaps` that make up a cluster
    yInds : array_like
            Indices of all the yGaps in `gaps` that make up a cluster
    gaps : array_like
           An array of all gaps (x and y) vstacked together

    Returns
    -------
    cwSortedPoints : list
                     List of outer points of the cluster of points sorted into
                     clockwise order, starting from the top right(ish) point
    """

    # outerPoints = np.zeros([np.shape(gaps[:,1])[0]*2,2])
    global outerPoints
    outerPoints = []
    
    def getCrossInds(testGap, crossGaps):
        """Finds the indices of all the lines that cross `testGap`.
           
        Parameters
        ----------
        testGap : array_like
                  The gap for which we want to know which lines cross
        crossGaps : array_like
                    The gaps that may or may not cross testGap

        Returns
        -------
        list
            List of indices in `gaps` of lines that cross `testGap`
        """
        crossInds = []
        
        for i in range(np.shape(crossGaps[:,1])[0]):
            if doesCross(testGap,crossGaps[i,:]):
                crossInds.append(i)
        return crossInds
    
    def stepByStep(point, allPoints, clockWPoints):
        """Function that finds the next point in clockwise order.
        
        Parameters
        ----------
        point : array_like
                The point from which we are stepping
        allpoints : array_like
                    The list of all outer points
        clockWPoints : array_like
                       List of points that have already been clockwise sorted

        Returns
        -------
        nextPoint : ndarray
                    The next point in clockwise order
        """

        def takeStep(pointsDf, clockWPoints):
            """Finds the next point coordinates in the step.
            
            Parameters
            ----------
            pointsDf : Pandas DataFrame 
                       Point coordinates with distances from the point of
                       interest
            clockWPoints : array_like
                           List of points already sorted into clockwise order

            Returns
            -------
            testPoint : array_like
                        The next point in clockwise order
            """

            i = 0
            while True:
                testPoint = pointsDf.iloc[i].to_numpy()                
                # Test to see if the test point has been sorted already
                test = True
                for cwPoint in clockWPoints:
                    if testPoint[0] == cwPoint[0] and \
                       testPoint[1] == cwPoint[1]:
                           test = False
                          
                           
                if (not test) and (i + 1) < pointsDf.shape[0]:
                    i += 1
                else:
                    break
                
            return testPoint

        # Find closest points
        dists = np.linalg.norm(point - allPoints, axis=-1 )
        pointsDists = np.column_stack((allPoints,dists))
        df = pd.DataFrame(pointsDists)
        df = df.sort_values(2)
        
        nextPoint = takeStep(df, clockWPoints)
        
        return nextPoint
    
    
    for ind in xInds:
        thisGap = gaps[ind,:]
        crossingInds = getCrossInds(thisGap,gaps[yInds,:])
        crossingInds = list(itemgetter(*crossingInds)(yInds))
        crossingYs = gaps[:,1]
        crossingYs = list(itemgetter(*crossingInds)(crossingYs))
        minY = min(crossingYs)
        maxY = max(crossingYs)
        x = gaps[ind,1]
        thesePoints = np.asarray([np.asarray([x,minY]),np.asarray([x,maxY])])
        outerPoints.append(thesePoints)
    
    for ind in yInds:
        thisGap = gaps[ind,:]
        crossingInds = getCrossInds(thisGap,gaps[xInds,:])
        crossingInds = list(itemgetter(*crossingInds)(xInds))
        crossingXs = gaps[:,1]
        crossingXs = list(itemgetter(*crossingInds)(crossingXs))
        minX = min(crossingXs)
        maxX = max(crossingXs)
        y = gaps[ind,1]
        thesePoints = np.asarray([np.asarray([minX,y]),np.asarray([maxX,y])])
        outerPoints.append(thesePoints)
    
    # Convert to list of 2-element arrays
    outerPoints = np.vstack(outerPoints)
    outerPoints = list(outerPoints)
    # Remove any duplicates
    outerUnique = pd.DataFrame(outerPoints)
    outerUnique = list(outerUnique.drop_duplicates().values)
    outerPoints = np.asarray(outerUnique)
    
    
    # Walk around the perimter and put all the points in clockwise order
    # Get starting point
    topRowInds = np.where(outerPoints[:,1] == max(outerPoints[:,1]))[0]
    topRowPoints = outerPoints[topRowInds,:]
    rightCornerInd = np.where(topRowPoints[:,0] == max(topRowPoints[:,0]))[0]
    topRightPoint = topRowPoints[rightCornerInd,:][0]
    xMatches = np.where(topRightPoint[0] == outerPoints[:,0])[0]
    yMatches = np.where(topRightPoint[1] == outerPoints[:,1])[0]
    startRowInd = np.intersect1d(xMatches, yMatches)
    antiCWNeighborPoint = topRowPoints[np.argsort(topRowPoints[:,0], 
                                                  axis=0)[-2],:]
    
    cwSortedPoints = [antiCWNeighborPoint, topRightPoint]
    
    global nextPoint
    nextPoint = stepByStep(outerPoints[startRowInd], 
                           outerPoints, 
                           cwSortedPoints)
    
    while True: 
        if min(np.linalg.norm(nextPoint[0:2]-  cwSortedPoints, axis=-1)) == 0:
            break
        else:
            cwSortedPoints.append(nextPoint[0:2])
            nextPoint = stepByStep(nextPoint[0:2], 
                                   outerPoints, 
                                   cwSortedPoints)
    
    # return outerPoints
    return cwSortedPoints

# ---------------Find intersections in clusters---------------
def clusterIntersections(xInds, yInds, gaps):
    """Finds intersections of lines in a cluster of connected lines.
    
    Finds all the intersection points between xGaps and yGaps, and returns a
    list of shapely points
    
    Parameters
    ----------
    xInds : array_like
            Indices of xGaps in the cluster
    yInds : array_like
            Indices of yGaps in the cluster
    gaps : array_like
           List of all gap line segment endpoints

    Returns
    -------
    intersections : list
                    List containing shapely points of each intersection in the
                    cluster
    """

    intersections = []
    
    _xGaps = list(itemgetter(*xInds)(gaps))
    _yGaps = list(itemgetter(*yInds)(gaps))
    
    
    # Make linestrings
    gapLineStrings = []
    
    for gap in _xGaps:
        thisGapLS = LineString(gap)
        gapLineStrings.append(thisGapLS)
            
    for gap in _yGaps:
        thisGapLS = LineString(gap)
        gapLineStrings.append(thisGapLS)
        
    intersections = findIntersections(gapLineStrings)
    
    return intersections

# -------------Generate polygons with alphashapes------------- 
def generateAlphaPolygons(xClusters, yClusters, gaps, alpha):
    """Generates polygons for data gaps using alphashape.


    Returns shapely polygons in a GeoDataFrame. Less precise polygons, but more
    resilient than generateRimPolygons.

    Parameters
    ----------
    xClusters : array_like
                List of xgap indices in each cluster
    yClusters : array_like
                List of ygap indices in each cluster
    gaps : array_like
           List of all gap line segment endpoints
    alpha : int
            Alpha value for alphashape
    """

    def makeAlphaShape(points, alpha):
        """Generate alphashapes with the libpysal alpha_shape module.
        
        Parameters
        ----------
        points : array_like
                 shapely points of one cluster
        alpha : int
                The alpha value used for the alpha shapes function

        Returns
        -------
        alpha_shape : GeoDataFrame
                      shapely polygon or multipolygon of alpha shapes
        """
       
        xs = np.asarray([point.x for point in points])
        ys = np.asarray([point.y for point in points])

        xy = np.vstack([xs,ys]).T
        
        shape = alpha_shape(xy, alpha)

        return shape

    shapes = []
    
    for i in range(len(xClusters)):
        xInds = xClusters[i]
        yInds = yClusters[i]
        
        inters = clusterIntersections(xInds, yInds, gaps)
        global aShape
        aShape = makeAlphaShape(inters, alpha)[0]
        
        if type(aShape) == MultiPolygon: # Only put polygons into list
            for sh in aShape: 
                shapes.append(sh)
        else:
            shapes.append(aShape)
    
    df = gpd.GeoDataFrame(shapes,columns=['geometry'],crs="EPSG:4326")
    df.set_geometry(col='geometry', inplace=True)
    
    return df

# -------------Generate polygons with outer poitns------------ 
def generateRimPolygons(xClusters,yClusters, gapSegments, gaps):
    """Generates polygons by finding the corners of the gap region.

    Generates polygons by finding the outer rim of intersections between x
    and y gaps. Returns shapely polygons in GeoDataFrame
    Requires parameters to be well tuned or you will get wacky polygons.
    
    Parameters
    ---------
    xClusters : array_like
                xgap indices in each cluster
    yClusters : array_like
                ygap indices in each cluster
    gapSegments : array_like
                  All gap line segment endpoints
    gaps : array_like
           Array of all data gaps
    
    Returns
    -------
    GeoDataFrame
        Polygons of data gaps
    """

    def cleanPoints(points):
        """Cleans an array of points of unnecessary points"""
        return findCorners(points)
    
    shapes = []
    
    for i in range(len(xClusters)):
        xInds = xClusters[i]
        yInds = yClusters[i]
        
        outerPoints = getOuterPoints(xInds, yInds, gaps)
        # outerPoints = findCorners(outerPoints)
        
        # Make shapely polygon from points
        shape = shapely.geometry.Polygon(outerPoints)
        shapes.append(shape)
    
    df = gpd.GeoDataFrame(shapes,columns=['geometry'],crs='EPSG:4326')
    df.set_geometry(col='geometry', inplace=True)
    return df

def mindTheGap(inFile,
                xBinSize, 
                yBinSize,
                xGapLenThreshold,
                yGapLenThreshold,
                xMinIntersections, 
                yMinIntersections,
                polygonType='alpha',
                alpha=22,
                writePoints = False):
    """Finds gaps in geographic point data.
    
    Given a set of points in 2D space, this function will find gaps in
    points, with adjustable sensitivity. This is best suited to identify
    rectilinear systematic gaps, such as those resulting from missing
    imagery. However it can also find gaps resulting from natural
    features- such as lakes or forests. Produces either polygons representing 
    gaps or points filling in the gap area.

    Parameters : 
    inFile : string
             Point data (e.g. buildings centroids) input file path
    xBinSize : float
               Width of vertical strips to identify gaps in whatever units the
               data is projected in
    yBinSize : float
               Width of horizontal strips to identify gaps in whatever units
               the data is projected in
    xGapLenThreshold : float
                       Minimum length data projection units for an xGap to be 
                       retained
    yGapLenThreshold : float
                       Minimum length in projection units for a yGap to be
                       retained
    xMinIntersections : int
                        Minimum number of intersections to filter gap lines
    yMinIntersections : int
                        Minimum number of intersections to filter gap lines
    polygonType : string
                  Either 'alpha' or 'rim'. The type of polygon generation to 
                  be used
    writePoints : boolean
                  If True, this function will return a GeoDataFrame of points 
                  that fill in the data gap instead of polygons.

    Returns
    -------
    GeoDataFrame
        Either polygons or points representing the data gap
    """

    def genGapLineStrings(xGaps, yGaps):
        """Converts data gaps from ndarrays to shapely linestrings"""
        xGaps = np.asarray(xGaps)
        xGapSegments = []
        xGapLineStrings = []
        for o in range(np.shape(xGaps[:,0])[0]):
            # Get segments ready to plot
            thisGapSegment = [(xGaps[o,1], xGaps[o,3]),\
                              (xGaps[o,1], xGaps[o,5])]
            xGapSegments.append(thisGapSegment)
            
            # Make LineStrings for Shapely
            thisLine = LineString([(xGaps[o,1], xGaps[o,3]),\
                                   (xGaps[o,1], xGaps[o,5])])
            xGapLineStrings.append(thisLine)
            
        allGapSegments = xGapSegments
        allGapLineStrings = xGapLineStrings
        yGaps = np.asarray(yGaps)
        yGapSegments = []
        yGapLineStrings = []
        for u in range(np.shape(yGaps[:,0])[0]):
            # Get segments ready to plot
            thisGapSegment = [(yGaps[u,3], yGaps[u,1]),\
                              (yGaps[u,5], yGaps[u,1])]
            yGapSegments.append(thisGapSegment)
            allGapSegments.append(thisGapSegment)
            
            # Make LineStrings for Shapely
            thisLine = LineString([(yGaps[u,3], yGaps[u,1]),\
                                   (yGaps[u,5], yGaps[u,1])])
            yGapLineStrings.append(thisLine)
            allGapLineStrings.append(thisLine)
        
        return allGapLineStrings, allGapSegments, xGapLineStrings, \
            yGapLineStrings        
        
    #Load in building centroids
    buildingCentroidsGdf = loadPoints(inFile)
    pointCoords = getCoordinates(buildingCentroidsGdf)
    
    # Add columns to point coordinates of which Lon and Lat bins it goes in
    stacked, xBins, yBins = intoTheBins(pointCoords,
                                        xBinSize,
                                        yBinSize)
    
    xGaps = findLatGaps(stacked, xBins, xGapLenThreshold)
    yGaps = findLonGaps(stacked, yBins, yGapLenThreshold)
    
    # Plot gaps before filter for test purposes:
    # allGapLineStrings, allGapSegments, xGapLineStrings, yGapLineStrings = \
    #     genGapLineStrings(xGaps, yGaps)
    # lc = mc.LineCollection(allGapSegments, linewidths=0.5)
    # fig, ax = pl.subplots()
    # ax.add_collection(lc)
    # ax.autoscale()
    # ax.margins(0.1) 
    
    # ---------Filter out gap strips without intersections--------
    xGaps, yGaps = intersectionFilter(xGaps,
                                      yGaps,
                                      xMinIntersections,
                                      yMinIntersections)
    
    # ------------------Generate gap LineStrings------------------   
    allGapLineStrings, allGapSegments, xGapLineStrings, yGapLineStrings \
        = genGapLineStrings(xGaps, yGaps)
    
    lc = mc.LineCollection(allGapSegments, linewidths=0.5)
    fig, ax = pl.subplots()
    ax.add_collection(lc)
    ax.autoscale()
    ax.margins(0.1) 
    # ---------------Find intersections with shapely--------------
    intersections = findIntersections(allGapLineStrings)
    
    # Make and return geodataframe of points if that is desired
    if writePoints:
        pointsGdf = gpd.GeoDataFrame(intersections, 
                                     columns=['geometry'],
                                     crs="EPSG:4326")
        pointsGdf.set_geometry(col='geometry', inplace=True)
        
        return pointsGdf

    # ------------------Sort points into clusters-----------------
    allGaps, IDs, gapClusters, splitInd = findClusters(xGaps,yGaps)

    # Need to separate xGaps and yGaps for each cluster
    clusterX = []
    clusterY = []
    for cluster in gapClusters:
        thisClusterXGaps = []
        thisClusterYGaps = []
        for gap in cluster:
            if gap < splitInd:
                thisClusterXGaps.append(gap)
            else:
                thisClusterYGaps.append(gap)
        clusterX.append(thisClusterXGaps)
        clusterY.append(thisClusterYGaps)
        
    # ------------------------Make polygons-----------------------
    if (polygonType == 'alpha'):
        polygons = generateAlphaPolygons(clusterX, 
                                         clusterY, 
                                         allGapSegments, 
                                         alpha)
        return polygons
   
    if polygonType == 'rim':
        polygons = generateRimPolygons(clusterX, 
                                       clusterY, 
                                       allGapSegments, 
                                       allGaps)
        return polygons